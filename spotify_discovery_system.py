"""
Spotify Discovery System: Fetch NEW tracks from Spotify based on user listening patterns
"""
import json
import pandas as pd
import numpy as np
from typing import Dict, List, Tuple, Optional
from datetime import datetime, timedelta
from dataclasses import dataclass
import logging
from config import settings
import os
from spotify_client import SpotifyClient
from s3_client import S3Client
import json

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

@dataclass
class UserProfile:
    """User's music taste profile extracted from listening history"""
    top_genres: List[Tuple[str, float]]  # (genre, preference_score)
    top_artists: List[Tuple[str, float]]  # (artist, preference_score)
    preferred_popularity_range: Tuple[int, int]  # (min, max) popularity
    preferred_eras: List[str]  # time periods user likes
    preferred_duration_range: Tuple[int, int]  # (min_ms, max_ms)
    discovery_openness: float  # 0-1 how open to new genres/artists

class SpotifyDiscoveryEngine:
    """Main engine for discovering new music from Spotify's catalog"""
    
    def __init__(self):
        self.settings = settings
        self.spotify = SpotifyClient()
        self.s3_client = S3Client()
        
        # Valid Spotify genre seeds mapping
        self.genre_mapping = {
            'hip hop': 'hip-hop',
            'hip-hop': 'hip-hop',
            'alternative': 'alternative',
            'rock': 'rock',
            'pop': 'pop',
            'country': 'country',
            'electronic': 'electronic',
            'indie': 'indie',
            'metal': 'metal',
            'punk': 'punk',
            'r&b': 'r-n-b',
            'rnb': 'r-n-b',
            'jazz': 'jazz',
            'blues': 'blues',
            'reggae': 'reggae',
            'funk': 'funk',
            'soul': 'soul',
            'folk': 'folk',
            'classical': 'classical',
            'latin': 'latin',
            'world': 'world-music',
            'native american music': 'world-music',  # Fallback for unsupported genres
            'ambient': 'ambient',
            'house': 'house',
            'techno': 'techno',
            'dubstep': 'dubstep',
            'garage': 'garage',
            'disco': 'disco'
        }
        
    def get_user_profile(self) -> UserProfile:
        """Load user's music preferences from pre-generated profile file"""
        try:
            # Try to load from local file first (generated by SQL script)
            profile_file = 'user_music_profile.json'
            if os.path.exists(profile_file):
                with open(profile_file, 'r') as f:
                    profile_data = json.load(f)
                    
                return UserProfile(
                    top_genres=[(g['name'], g['score']) for g in profile_data['top_genres']],
                    top_artists=[(a['name'], a['score']) for a in profile_data['top_artists']],
                    preferred_popularity_range=tuple(profile_data['preferred_popularity_range']),
                    preferred_eras=profile_data['preferred_eras'],
                    preferred_duration_range=tuple(profile_data['preferred_duration_range']),
                    discovery_openness=profile_data['discovery_openness']
                )
        except Exception as e:
            logger.warning(f"Could not load user profile from file: {e}")
        
        # Fallback to default profile based on common preferences
        logger.info("Using default profile - run generate_user_profile.sql first for personalized recommendations")
        return UserProfile(
            top_genres=[
                ('rock', 0.3), ('pop', 0.25), ('indie', 0.2), 
                ('alternative', 0.15), ('electronic', 0.1)
            ],
            top_artists=[
                ('Various Artists', 0.1), ('Unknown Artist', 0.1)
            ],
            preferred_popularity_range=(20, 80),
            preferred_eras=['current', 'recent'],
            preferred_duration_range=(180000, 300000),  # 3-5 minutes
            discovery_openness=0.7
        )
    
    def search_spotify_recommendations(self, profile: UserProfile, limit: int = 50) -> List[Dict]:
        """Search Spotify for new tracks based on user profile"""
        discovered_tracks = []
        
        try:
            # Strategy 1: Use top artists as seeds
            for artist_name, preference in profile.top_artists[:5]:
                logger.info(f"Searching recommendations based on artist: {artist_name}")
                
                # Search for the artist
                artist_results = self.spotify.search(artist_name, 'artist', limit=1)
                if not artist_results['artists']['items']:
                    continue
                    
                artist_id = artist_results['artists']['items'][0]['id']
                
                try:
                    # Use search instead of recommendations API (workaround for app permissions)
                    search_query = f'artist:"{artist_name}" OR genre:rock OR genre:pop OR genre:alternative'
                    search_results = self.spotify.search(search_query, 'track', limit=10)
                    
                    tracks = search_results.get('tracks', {}).get('items', [])
                    
                    for track in tracks:
                        discovered_tracks.append({
                            'track_id': track['id'],
                            'track_name': track['name'],
                            'primary_artist_name': track['artists'][0]['name'],
                            'primary_artist_id': track['artists'][0]['id'],
                            'album_name': track['album']['name'],
                            'album_release_date': track['album']['release_date'],
                            'track_popularity': track['popularity'],
                            'track_duration_ms': track['duration_ms'],
                            'preview_url': track['preview_url'],
                            'discovery_strategy': 'artist_based',
                            'seed_artist': artist_name,
                            'preference_score': preference,
                            'discovered_at': datetime.now()
                        })
                except Exception as e:
                    logger.error(f"Failed to get recommendations for artist {artist_name}: {e}")
                    continue
            
            # Strategy 2: Use top genres for discovery
            for genre, preference in profile.top_genres[:3]:
                # Map to valid Spotify genre
                spotify_genre = self.genre_mapping.get(genre.lower(), None)
                if not spotify_genre:
                    logger.warning(f"Genre '{genre}' not supported, skipping")
                    continue
                    
                logger.info(f"Searching recommendations for genre: {genre} -> {spotify_genre}")
                
                try:
                    # Use search instead of recommendations API (workaround for app permissions)
                    search_query = f'genre:{spotify_genre}'
                    search_results = self.spotify.search(search_query, 'track', limit=10)
                    
                    tracks = search_results.get('tracks', {}).get('items', [])
                    
                    for track in tracks:
                        discovered_tracks.append({
                            'track_id': track['id'],
                            'track_name': track['name'],
                            'primary_artist_name': track['artists'][0]['name'],
                            'primary_artist_id': track['artists'][0]['id'],
                            'album_name': track['album']['name'],
                            'album_release_date': track['album']['release_date'],
                            'track_popularity': track['popularity'],
                            'track_duration_ms': track['duration_ms'],
                            'preview_url': track['preview_url'],
                            'discovery_strategy': 'genre_based',
                            'seed_genre': genre,
                            'preference_score': preference,
                            'discovered_at': datetime.now()
                        })
                        
                except Exception as e:
                    logger.warning(f"Failed to get recommendations for genre {genre}: {e}")
                    continue
                    
        except Exception as e:
            logger.error(f"Error during Spotify recommendations: {e}")
            
        # Remove duplicates and limit results
        seen_tracks = set()
        unique_tracks = []
        for track in discovered_tracks:
            if track['track_id'] not in seen_tracks:
                seen_tracks.add(track['track_id'])
                unique_tracks.append(track)
                
        return unique_tracks[:limit]
    
    def save_discoveries_to_s3(self, discoveries: List[Dict]) -> None:
        """Save discovered tracks to S3 for Snowpipe ingestion"""
        if not discoveries:
            logger.warning("No discoveries to save")
            return
            
        # Create timestamp for file naming
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        
        # Prepare data for S3 (convert datetime objects to strings)
        processed_discoveries = []
        for discovery in discoveries:
            # Create a copy with datetime converted to string
            processed_discovery = discovery.copy()
            processed_discovery['discovered_at'] = discovery['discovered_at'].isoformat()
            processed_discoveries.append(processed_discovery)
        
        try:
            # Create JSON Lines content for discovery data
            jsonl_content = '\n'.join(json.dumps(discovery) for discovery in processed_discoveries)
            
            # Upload directly to spotify_discoveries/ path (OPTION B - dedicated discovery path)
            discovery_s3_key = f"spotify_discoveries/{timestamp}/discovered_tracks_{timestamp}.json"
            
            # Direct S3 upload to discovery path
            self.s3_client.s3_client.put_object(
                Bucket=self.s3_client.bucket_name,
                Key=discovery_s3_key,
                Body=jsonl_content.encode('utf-8'),
                ContentType='application/json'
            )
            
            logger.info(f"âœ… Saved {len(discoveries)} discoveries to S3: s3://{self.s3_client.bucket_name}/{discovery_s3_key}")
            
            # Also save locally for reference  
            local_file = f"discovered_tracks_{timestamp}.json"
            with open(local_file, 'w') as f:
                f.write(jsonl_content)
            logger.info(f"âœ… Saved copy locally: {local_file}")
            
        except Exception as e:
            logger.error(f"Failed to save discoveries to S3: {e}")
            # Save locally as backup
            backup_file = f"backup_discoveries_{timestamp}.json"
            with open(backup_file, 'w') as f:
                jsonl_content = '\n'.join(json.dumps(discovery) for discovery in processed_discoveries)
                f.write(jsonl_content)
            logger.info(f"ğŸ’¾ Saved backup locally: {backup_file}")
            raise
    
    def run_discovery_pipeline(self, limit: int = 50) -> Dict:
        """Main pipeline: analyze user â†’ discover tracks â†’ save to S3"""
        logger.info("Starting Spotify discovery pipeline...")
        
        # Step 1: Analyze user preferences
        logger.info("Analyzing user listening patterns...")
        profile = self.get_user_profile()
        
        # Step 2: Search Spotify for new tracks
        logger.info("Searching Spotify for new tracks...")
        discoveries = self.search_spotify_recommendations(profile, limit)
        
        # Step 3: Save to S3 (Snowpipe will auto-ingest)
        logger.info("Saving discoveries to S3...")
        self.save_discoveries_to_s3(discoveries)
        
        # Step 4: Generate summary
        summary = {
            'total_discoveries': len(discoveries),
            'top_genres': profile.top_genres[:3],
            'top_artists': profile.top_artists[:3],
            'discovery_strategies': list(set(d['discovery_strategy'] for d in discoveries)),
            'avg_popularity': np.mean([d['track_popularity'] for d in discoveries]),
            'discovery_timestamp': datetime.now()
        }
        
        logger.info(f"Discovery pipeline complete: {summary}")
        return summary

def main():
    """Run the discovery pipeline"""
    engine = SpotifyDiscoveryEngine()
    summary = engine.run_discovery_pipeline(limit=50)
    
    print(f"""
    ğŸµ SPOTIFY DISCOVERY COMPLETE ğŸµ
    
    ğŸ“Š Discovered {summary['total_discoveries']} new tracks
    ğŸ­ Based on your top genres: {', '.join([g[0] for g in summary['top_genres']])}
    ğŸ¤ Based on your top artists: {', '.join([a[0] for a in summary['top_artists']])}
    ğŸ“ˆ Average popularity: {summary['avg_popularity']:.1f}
    â˜ï¸  Saved to S3 - Snowpipe will auto-ingest!
    
    Next steps:
    1. Set up Snowpipe for spotify_discoveries/ (similar to listening history)
    2. Run the discovery recommendation SQL views
    3. Check your new recommendations!
    """)

if __name__ == "__main__":
    main()
